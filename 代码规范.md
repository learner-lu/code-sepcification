代码规范
---
采用中译版谷歌[C++代码规范](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/)
---

1. Google 公司提供了代码规范检查风格错误,python2可以直接[复制代码](http://github.com/google/styleguide/blob/gh-pages/cpplint/cpplint.py),python3运行该程序有问题,笔者已进行改正,现已上传并提供[下载地址]()
   <br>使用方法:
   ```python
   python cpplint.py xxx/xxx.cpp
   ```
   **请根据其中的错误信息做出修改**
2. 务必仔细阅读`7.命名约定`,`8.注释`,`9.格式`,笔者不会为其做摘要总结.**这一部分十分重要**
---

- 0 背景<br>
  
  C++ 是 Google 大部分开源项目的主要编程语言. 正如每个 C++ 程序员都知道的, C++ 有很多强大的特性, 但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug, 难以阅读和维护.

  本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性. 这些规则在保证代码易于管理的同时, 也能高效使用 C++ 的语言特性.

  风格, 亦被称作可读性, 也就是指导 C++ 编程的约定. 使用术语 “风格” 有些用词不当, 因为这些习惯远不止源代码文件格式化这么简单.

  使代码易于管理的方法之一是加强代码一致性. 让任何程序员都可以快速读懂你的代码这点非常重要. 保持统一编程风格并遵守约定意味着可以很容易根据 “模式匹配” 规则来推断各种标识符的含义. 创建通用, 必需的习惯用语和模式可以使代码更容易理解. 在一些情况下可能有充分的理由改变某些编程风格, 但我们还是应该遵循一致性原则，尽量不这么做.

  本指南的另一个观点是 C++ 特性的臃肿. C++ 是一门包含大量高级特性的庞大语言. 某些情况下, 我们会限制甚至禁止使用某些特性. 这么做是为了保持代码清爽, 避免这些特性可能导致的各种问题. 指南中列举了这类特性, 并解释为什么这些特性被限制使用.

  Google 主导的开源项目均符合本指南的规定.

  **注意: 本指南并非 C++ 教程, 我们假定读者已经对 C++ 非常熟悉.**

- 1.头文件<br>
  - 除单元测试代码和主程序入口,每一个`.cpp`文件都需要对应一个`.h`文件
  - 为了保护唯一性，头文件的命名应该基于所在项目源代码树的全路径.例如项目`foo`中的头文件`foo/src/bar/baz.h`可按如下方式保护
    ```cpp
    #ifndef FOO_BAR_BAZ_H_
    #define FOO_BAR_BAZ_H_
    ...
    #endif // FOO_BAR_BAZ_H_
    ```
  - 尽可能避免使用前置声明,使用`#include`包含所需的头文件,详见1.3前置声明
  - 项目内头文件应按照源代码目录树结构排列,不应使用`.`(当前目录),`..`(上级目录)
  - 如`dir/foo_test.c`的作用是实现或测试`dir/foo.h`的功能,其头文件引用次序应该为
    - `dir/foo.h`(优先位置)
    - c系统文件
    - c++系统文件
    - 其他库`.h`文件
    - 本项目内`.h`文件
- 2.作用域<br>
  **鼓励使用匿名命名空间或`static`命名.使用具名的命名空间时, 其名称可基于项目名或相对路径. 禁止使用`using`指示禁止使用内联命名空间(inline namespace).**
  - 不要在`.h`中定义不需要被外部引用的变量  
  - 使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.应使用
    ```cpp
    namespace myproject {
    namespace foo_bar {
    void Function1();
    void Function2();
    }  // namespace foo_bar
    }  // namespace myproject
    ```
    而非
    ```cpp
    namespace myproject {
    class FooBar {
     public:
      static void Function1();
      static void Function2();
    };
    }  // namespace myproject
    ```
  - 函数变量应置于最小的作用域内,并在变量声明时进行初始化
    ```cpp
    int i;
    i = f(); // 坏——初始化和声明分离
    ```
    ```cpp
    int j = g(); // 好——初始化时声明
    ```
    ```cpp
    vector<int> v;
    v.push_back(1); // 用花括号初始化更好
    v.push_back(2);
    ```
    ```cpp
    vector<int> v = {1, 2}; // 好——v 一开始就初始化
    ```
    属于 if, while 和 for 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中
    <br>有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低.
    ```cpp
    // 低效的实现
    for (int i = 0; i < 1000000; ++i) {
    Foo f;                  // 构造函数和析构函数分别调用 1000000 次!
    f.DoSomething(i);
    }
    ```
    在循环作用域外面声明这类变量要高效的多:
    ```cpp
    Foo f;                      // 构造函数和析构函数只调用 1 次
    for (int i = 0; i < 1000000; ++i) {
    f.DoSomething(i);
    }
    ```
- 3.类
  - 不要在构造函数中调用虚函数,构造函数中可以进行各种初始化操作,不在构造函数中做太多逻辑相关的初始化
  - 不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用`explicit`关键字
  - 仅当只有数据成员时使用`struct`, 其它一概使用`class`.
  - 将相似的声明放在一起, 将`public`部分放在最前.类定义一般应以`public:`开始, 后跟`protected:`, 最后是`private:`. 省略空部分.
- 4.函数
  - 我们倾向于按值返回,否则按引用返回,避免返回指针,除非它可以为空.
  - 我们倾向于编写简短, 凝练的函数.我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过**40**行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.
  即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题, 甚至导致难以发现的 bug. 使函数尽量简短, 以便于他人阅读和修改代码.
  - 所有按引用传递的参数必须加上`const`.在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如`int foo(int *pval)`. 在`C++`中, 函数还可以声明为引用参数:`int foo(int &val).`
  <br>`Google Code`中有一个硬性约定: 输入参数是值参或 const 引用, 输出参数为指针. 
    ```cpp
    void Foo(const string &in, string *out);
    ```
    `const &`指针有很多好处,比如避免值传递时的复制/调用构造函数,并且保证参数不被修改
  - 大多时候输入形参往往是`const T&`,若用`const T*`则说明输入另有处理. 所以若要使用`const T*`, 则应给出相应的理由, 否则会使得读者感到迷惑.
  - 若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用`AppendString()`和`AppendInt()`等, 而不是一口气重载多个`Append()`
  - 只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法.
- 5.C++特性
  - 所有按引用传递的参数必须加上`const.`
  - 我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载.
  - 我们不使用 C++ 异常(Google要求,但个人使用或团队项目还是推荐使用异常处理或异常捕获).
    <br>[异常处理的态度](http://www.zhihu.com/question/22889420),值得一读
  - 使用 C++ 的类型转换, 如`static_cast<>()`. 不要使用`int y = (int)x`或`int y = int(x)`等转换方式;
  - 对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, 自减运算符.
    ```
    不考虑返回值的话, 前置自增 (++i) 通常要比后置自增 (i++) 效率更高. 
    因为后置自增 (或自减) 需要对表达式的值 i 进行一次拷贝. 
    如果 i 是迭代器或其他非数值类型, 拷贝的代价是比较大的. 
    ```
  - 我们强烈建议你在任何可能的情况下都要使用 const. 此外有时改用 C++11 推出的 constexpr 更好.在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。
  - 使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.
---
最后特别鸣谢该网站的翻译作者,谢谢
